#include "/Engine/Private/Common.ush"

//--------------------------------------------------------------------------------------
// Structs
//--------------------------------------------------------------------------------------
struct Particle{
    float3 position;
    float3 velocity;
    float  time;
};

//--------------------------------------------------------------------------------------
// Buffers
//--------------------------------------------------------------------------------------

RWStructuredBuffer<Particle> particles_read;
RWStructuredBuffer<Particle> particles_write;
float delta_time;
float mass;
float gravity;
float eps = 1.7f;
float sig = 1.f;

int numParticles;

float ComputeAcceleration(float force, float mass){
    return force / mass;
}
float ComputeGravitationalForce(float mass){
    return mass * gravity;
}

float ComputeForce(float r)
{	

	//V = 4 * eps * (pow(sig / r, 12) - pow(sig / r, 6)); // potencial field
	float U = 4 * eps * ((pow(6 * sig, 6) / pow(r, 7)) - (pow(12 * sig, 12) / pow(r, 13)));
	return U;
}

float3 addForce(in float3 velocity,in float3 force){
    const float ts = 0.016f;
    velocity += (force / mass) * ts;
    return velocity;
}

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void MainComputeShader(uint3 ThreadId : SV_DispatchThreadID)
{
    int index = ThreadId.x;
    const float ts = 0.016f;

    float3 position = particles_read[index].position;
    float time = particles_read[index].time;
    float3 velocity = particles_read[index].velocity;

	float3 new_velocity = velocity; 
    //position.z += sin(time);
    
    float3 G = float3(0.0f,0.0f,-1.0f) * ComputeGravitationalForce(mass);

    new_velocity = addForce(new_velocity, G);

    float3 fce = float3(0.0f,0.0f,0.0f);
    for(int i = 0; i < index; i++){
        float3 loc = particles_read[i].position;
        float3 res = loc - position;
        float u = ComputeForce(length(res));
        fce += u * normalize(res);
    }
    for(int i = index + 1; i < numParticles; i++){
        float3 loc = particles_read[i].position;
        float3 res = loc - position;
        float u = ComputeForce(length(res));
        fce += u * normalize(res);
    }
    new_velocity = addForce(new_velocity, fce);
    
    particles_write[index].velocity = new_velocity;
    particles_write[index].time += ts;
    particles_write[index].position = position + new_velocity;
}
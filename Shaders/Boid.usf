#include "/Engine/Private/Common.ush"

//--------------------------------------------------------------------------------------
// Structs
//--------------------------------------------------------------------------------------
struct Particle{
    float3 position;
    float3 velocity;
};
struct ParticleForce {
	float3 force;
};
struct ParticleDensity {
	float density;
};
//--------------------------------------------------------------------------------------
// Buffers
//--------------------------------------------------------------------------------------

RWStructuredBuffer<Particle> particles_read;
RWStructuredBuffer<Particle> particles_write;

RWStructuredBuffer<ParticleForce> particlesForce_read;
RWStructuredBuffer<ParticleForce> particlesForce_write;

RWStructuredBuffer<ParticleDensity> particlesDensity_read;
RWStructuredBuffer<ParticleDensity> particlesDensity_write;

float delta_time;
float mass;
float gravity;
float eps = 1.7f;
float sig = 1.f;

int numParticles;
float3 minBoundary;
float3 maxBoundary;
float  damping;
float  epsilon;
float  radious;
float  poly6Kernel;
float  spikyKernel;
float  lapKernel;
float  pressureCoef;
float  restDensity;
float  viscosity;

float ComputeDensity(float dist_sq, float er_sq ){
    float x =   1 - dist_sq / er_sq;
    return mass * poly6Kernel * x * x * x;
}

float SpikyKernelSecondDerivative(float distance)
{
    float x = 1 - distance / radious ;
    return 90.f / ( 3.14 * pow(radious,5)) * x;
}


[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void Density(uint3 ThreadId : SV_DispatchThreadID)
{
   int index = ThreadId.x;
   if(index >= numParticles) return;
   Particle particle = particles_read[index];
   const float er_sq = radious * radious;
   float density = 0;

   float3 position = particle.position;
   
   //O(n^2) density calculation
   for(int i = 0; i < numParticles; i++){
        float3 other = particles_read[i].position;
        float3 res = other - position;
        float dist_sq = dot(res,res);
        if(dist_sq < er_sq){
            density += ComputeDensity(dist_sq,er_sq);
        }
   }
   // Update density
   particlesDensity_write[index].density = density;
}

float ComputePressure(float density){
   //density = max(density, restDensity);
   return pressureCoef * (density - restDensity);
}

float3 ComputeLapVelocity(float dist, float3 velocity, float3 i_velocity, float i_density){
    float3 vdiff = i_velocity - velocity;
    float mass_ratio = mass / mass;
    float diff =  1 - dist / radious;
    float lap = lapKernel * diff;
    return mass_ratio * viscosity * (1/i_density) * lap * vdiff; 
}
float3 ComputeGradPressure(float dist, float pressure, float density, float i_pressure, float i_density)
{

    float i_density2 = i_density * i_density;
    float density2 = density * density;
	float avgPressure = 0.5 * (i_pressure / i_density + pressure / density );
    float mass_ratio = mass / mass;
    float diff =  1 - dist / radious;
    float spiky = spikyKernel * diff * diff;
    return mass_ratio * avgPressure * spiky;
}

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void Force(uint3 ThreadId : SV_DispatchThreadID)
{
   int index = ThreadId.x;
   if(index >= numParticles)
        return;

   float3 position = particles_read[index].position;
   float3 velocity = particles_read[index].velocity;
   float density = particlesDensity_read[index].density;
   float pressure = ComputePressure(density);

   const float er_sq = radious * radious;
   float3 force = float3(0,0,0);

   //O(n^2) force calculation
   for(int i = 0; i < numParticles; i++){
        if(i == index) continue;
        float3 other = particles_read[i].position;
        float3 res = other - position;
        float dist_sq = dot(res,res);
        if(dist_sq < er_sq && dist_sq > 0 ){
            float3 i_velocity = particles_read[i].velocity;
            float i_density = particlesDensity_read[i].density;
            float i_pressure = ComputePressure(i_density);
            float dist = sqrt(dist_sq);
            force -= normalize(res) * ComputeGradPressure(dist, pressure, density, i_pressure, i_density);
            force += ComputeLapVelocity(dist, velocity, i_velocity, i_density);
        }
   }
   //update
   force += float3(0.0f,0.0f,1.0f) * gravity;
   particlesForce_write[index].force = force;
}


[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void MainComputeShader(uint3 ThreadId : SV_DispatchThreadID)
{
    int index = ThreadId.x;
    if(index >= numParticles) return;
    Particle particle = particles_read[index];

    
    float3 position = particles_read[index].position;
    float3 velocity = particles_read[index].velocity;
    float density = particlesDensity_read[index].density;
    
    float3 force = particlesForce_read[index].force;

    float3 acceleration = float3(0,0,0);
    acceleration +=  force / mass;

    velocity += acceleration * delta_time;
    position += velocity * delta_time;
    
    
    //enforce bounds
    if(position.x - epsilon < minBoundary.x){
        velocity.x *= damping;
        position.x  = minBoundary.x + epsilon;
    }
    else if(position.x + epsilon + 1 > maxBoundary.x){
        velocity.x *= damping;
        position.x  = maxBoundary.x - epsilon - 1;
    }


    if(position.y - epsilon < minBoundary.y){
        velocity.y *= damping;
        position.y  = minBoundary.y + epsilon;
    }else if(position.y + epsilon + 1 > maxBoundary.y){
        velocity.y *= damping;
        position.y  = maxBoundary.y - epsilon - 1;
    }
    if(position.z - epsilon < minBoundary.z){
        velocity.z *= damping;
        position.z  = minBoundary.z + epsilon;
    } else if(position.z + epsilon + 1 > maxBoundary.z){
        velocity.z *= damping;
        position.z  = maxBoundary.z - epsilon - 1;
    }
    
    




    particles_write[index].velocity = velocity;
    particles_write[index].position = position;
}
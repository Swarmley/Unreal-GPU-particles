#include "/Engine/Private/Common.ush"

//--------------------------------------------------------------------------------------
// Structs
//--------------------------------------------------------------------------------------
struct Particle{
    float3 position;
    float3 velocity;
};
struct ParticleForce {
	float3 force;
};
struct ParticleDensity {
	float density;
};
//--------------------------------------------------------------------------------------
// Buffers
//--------------------------------------------------------------------------------------

RWStructuredBuffer<Particle> particles_read;
RWStructuredBuffer<Particle> particles_write;

RWStructuredBuffer<ParticleForce> particlesForce_read;

RWStructuredBuffer<ParticleDensity> particlesDensity_read;

RWStructuredBuffer<float3> cvf_max;
RWStructuredBuffer<float> dt_read;
RWStructuredBuffer<float> dt_write;
RWStructuredBuffer<uint> mutex;


float mass;
float delta_time;
int numParticles;
float3 minBoundary;
float3 maxBoundary;
float  damping;
float  epsilon;

void Lock(){
    uint org;
    InterlockedCompareExchange(mutex[0],0,1, org);
    while(org != 0){    
        InterlockedCompareExchange(mutex[0],0,1,org);
    }
}
void Unlock(){
    uint org;
    InterlockedExchange(mutex[0], 0, org);
}

float evaluateSpeedOfSoundSquared(float pressure,float density) {
    //if (density < 0.00001f) {
    //    return 0.0f;
    //}
    return 1.0f*(pressure) / density;
}
groupshared float3 cache[THREADGROUPSIZE_X * THREADGROUPSIZE_Y * THREADGROUPSIZE_Z];
[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void DeltaTimeReduction(uint3 Gid : SV_GroupID, //atm: -, 0...256, - in rows (Y)        --> current group index (dispatched by c++)
                       uint3 ThreadId : SV_DispatchThreadID, //atm: 0...256 in rows & columns (XY)   --> "global" thread id
                       uint3 GTid : SV_GroupThreadID, //atm: 0...256, -,- in columns (X)      --> current threadId in group / "local" threadId
                       uint GI : SV_GroupIndex)
{

    //int index = ThreadId.x;
    //int cacheIdx = GTid.x;
    //float density = particlesDensity_read[index].density;
    //float pressure = ComputePressure(density);
    //float gamma = 1.0f;
    //float3 velocity = particles_read[index].velocity;
    //float3 force = particlesForce_read[index].force;
    //
    //
    //float vel_max = max(0,dot(velocity,velocity));
    //float force_max = max(0,dot(force, force));
    //float c_max = evaluateSpeedOfSoundSquared(pressure, density);
    //
    //cache[cacheIdx] = float3(c_max, vel_max, force_max);
    //GroupMemoryBarrierWithGroupSync();
    //
    //int step = numParticles >> 1;
    //while( step != 0 ) {
    //  if(cacheIdx < step){
    //    cache[cacheIdx].x = max(cache[cacheIdx].x, cache[cacheIdx + step].x);
    //    cache[cacheIdx].y = max(cache[cacheIdx].y, cache[cacheIdx + step].y);
    //    cache[cacheIdx].z = max(cache[cacheIdx].z, cache[cacheIdx + step].z);
    //  }
    //  GroupMemoryBarrierWithGroupSync();
    //  step = step >> 1; 
    //}
    //
    //if(cacheIdx == 0){
    //    Lock();
    //    cvf_max[0].x = max(cache[0].x, cvf_max[0].x);
    //    cvf_max[0].y = max(cache[0].y, cvf_max[0].y);
    //    cvf_max[0].z = max(cache[0].z, cvf_max[0].z);
    //    Unlock();
    //}
    ////GroupMemoryBarrierWithGroupSync();
    ////if(index == 0){
    ////    float C = 1.0f;
    ////    dt_write[0] = max(max(C * radious /  cvf_max[0].y, sqrt(radious/cvf_max[0].z)), (C * radious) / cvf_max[0].x);
    ////}

}

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void MainComputeShader(uint3 Gid : SV_GroupID, //atm: -, 0...256, - in rows (Y)        --> current group index (dispatched by c++)
                       uint3 ThreadId : SV_DispatchThreadID, //atm: 0...256 in rows & columns (XY)   --> "global" thread id
                       uint3 GTid : SV_GroupThreadID, //atm: 0...256, -,- in columns (X)      --> current threadId in group / "local" threadId
                       uint GI : SV_GroupIndex)            //atm: 0...256 in columns (X)           --> "flattened" index of a thread within a group))
{
    
    int index = ThreadId.x;
    if(index >= numParticles) return;
    Particle particle = particles_read[index];

    
    float3 position = particles_read[index].position;
    float3 velocity = particles_read[index].velocity;
    float density = particlesDensity_read[index].density;
    
    float3 force = particlesForce_read[index].force;

    float3 acceleration = float3(0,0,0);
    acceleration +=  force / mass;

    velocity += acceleration * delta_time;
    position += velocity * delta_time;
    
    
    //enforce bounds
    if(position.x - epsilon < minBoundary.x){
        velocity.x *= damping;
        position.x  = minBoundary.x + epsilon;
    }
    else if(position.x + epsilon + 1 > maxBoundary.x){
        velocity.x *= damping;
        position.x  = maxBoundary.x - epsilon - 1;
    }


    if(position.y - epsilon < minBoundary.y){
        velocity.y *= damping;
        position.y  = minBoundary.y + epsilon;
    }else if(position.y + epsilon + 1 > maxBoundary.y){
        velocity.y *= damping;
        position.y  = maxBoundary.y - epsilon - 1;
    }
    if(position.z - epsilon < minBoundary.z){
        velocity.z *= damping;
        position.z  = minBoundary.z + epsilon;
    } else if(position.z + epsilon + 1 > maxBoundary.z){
        velocity.z *= damping;
        position.z  = maxBoundary.z - epsilon - 1;
    }
    
    




    particles_write[index].velocity = velocity;
    particles_write[index].position = position;
}
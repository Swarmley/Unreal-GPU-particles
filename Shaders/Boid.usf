#include "/Engine/Private/Common.ush"

//--------------------------------------------------------------------------------------
// Structs
//--------------------------------------------------------------------------------------
struct Particle{
    float3 position;
    float3 velocity;
};
struct ParticleForce {
	float3 force;
};
struct ParticleDensity {
	float density;
};
//--------------------------------------------------------------------------------------
// Buffers
//--------------------------------------------------------------------------------------

RWStructuredBuffer<Particle> particles_read;
RWStructuredBuffer<Particle> particles_write;

RWStructuredBuffer<ParticleForce> particlesForce_read;
RWStructuredBuffer<ParticleForce> particlesForce_write;

RWStructuredBuffer<ParticleDensity> particlesDensity_read;
RWStructuredBuffer<ParticleDensity> particlesDensity_write;

RWStructuredBuffer<float3> cvf_max;



RWStructuredBuffer<float> dt_read;
RWStructuredBuffer<float> dt_write;
RWStructuredBuffer<uint> mutex;

float delta_time;
float mass;
float3 gravity;
int numParticles;
float3 minBoundary;
float3 maxBoundary;
float  damping;
float  epsilon;
float  radious;
float  poly6Kernel;
float  spikyKernel;
float  lapKernel;
float  pressureCoef;
float  restDensity;
float  viscosity;

float ComputeDensity(float dist_sq, float er_sq ){
    float x =   er_sq - dist_sq;
    return mass * poly6Kernel * x * x * x;
}



[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void Density(uint3 ThreadId : SV_DispatchThreadID)
{
   int index = ThreadId.x;
   if(index >= numParticles) return;
   Particle particle = particles_read[index];
   const float er_sq = radious * radious;
   float density = 0;

   float3 position = particle.position;
   
   //O(n^2) density calculation
   for(int i = 0; i < numParticles; i++){
        float3 other = particles_read[i].position;
        float3 res = other - position;
        float dist_sq = dot(res,res);
        if(dist_sq < er_sq){
            density += ComputeDensity(dist_sq,er_sq);
        }
   }
   // Update density
   particlesDensity_write[index].density = density;
}

float ComputePressure(float density){
   //density = max(density, restDensity);
   return pressureCoef * (density - restDensity);
}

float3 ComputeLapVelocity(float dist, float3 velocity, float3 i_velocity, float i_density){
    float3 vdiff = i_velocity - velocity;
    float mass_ratio = mass / mass;
    float diff =  radious- dist;
    float lap = lapKernel * diff;
    return mass_ratio * viscosity * (1/i_density) * lap * vdiff; 
}
float3 ComputeGradPressure(float dist, float pressure, float density, float i_pressure, float i_density)
{

    float i_density2 = i_density * i_density;
    float density2 = density * density;
	float avgPressure = 0.5 * (i_pressure / i_density + pressure / density );
    float mass_ratio = mass / mass;
    float diff =  radious- dist ;
    float spiky = spikyKernel * diff * diff;
    return mass_ratio * avgPressure * spiky;
}

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void Force(uint3 ThreadId : SV_DispatchThreadID)
{
   int index = ThreadId.x;
   if(index >= numParticles)
        return;

   float3 position = particles_read[index].position;
   float3 velocity = particles_read[index].velocity;
   float density = particlesDensity_read[index].density;
   float pressure = ComputePressure(density);

   const float er_sq = radious * radious;
   float3 force = float3(0,0,0);

   //O(n^2) force calculation
   for(int i = 0; i < numParticles; i++){
        if(i == index) continue;
        float3 other = particles_read[i].position;
        float3 res = other - position;
        float dist_sq = dot(res,res);
        if(dist_sq < er_sq && dist_sq > 0 ){
            float3 i_velocity = particles_read[i].velocity;
            float i_density = particlesDensity_read[i].density;
            float i_pressure = ComputePressure(i_density);
            float dist = sqrt(dist_sq);
            force -= normalize(res) * ComputeGradPressure(dist, pressure, density, i_pressure, i_density);
            force += ComputeLapVelocity(dist, velocity, i_velocity, i_density);
        }
   }
   //update
   force +=  gravity;
   particlesForce_write[index].force = force;
}
void Lock(){
    uint org;
    InterlockedCompareExchange(mutex[0],0,1, org);
    while(org != 0){    
        InterlockedCompareExchange(mutex[0],0,1,org);
    }
}
void Unlock(){
    uint org;
    InterlockedExchange(mutex[0], 0, org);
}

float evaluateSpeedOfSoundSquared(float pressure,float density) {
    if (density < 0.00001f) {
        return 0.0f;
    }
    return 1.0f*(pressure) / density;
}
groupshared float3 cache[THREADGROUPSIZE_X * THREADGROUPSIZE_Y * THREADGROUPSIZE_Z];
[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void DeltaTimeReduction(uint3 Gid : SV_GroupID, //atm: -, 0...256, - in rows (Y)        --> current group index (dispatched by c++)
                       uint3 ThreadId : SV_DispatchThreadID, //atm: 0...256 in rows & columns (XY)   --> "global" thread id
                       uint3 GTid : SV_GroupThreadID, //atm: 0...256, -,- in columns (X)      --> current threadId in group / "local" threadId
                       uint GI : SV_GroupIndex)
{

    int index = ThreadId.x;
    int cacheIdx = GTid.x;
    float density = particlesDensity_read[index].density;
    float pressure = ComputePressure(density);
    float gamma = 1.0f;
    float3 velocity = particles_read[index].velocity;
    float3 force = particlesForce_read[index].force;


    float vel_max = max(0,dot(velocity,velocity));
    float force_max = max(0,dot(force, force));
    float c_max = evaluateSpeedOfSoundSquared(pressure, density);

    cache[cacheIdx] = float3(c_max, vel_max, force_max);
    GroupMemoryBarrierWithGroupSync();

    int step = numParticles >> 1;
    while( step != 0 ) {
      if(cacheIdx < step){
        cache[cacheIdx].x = max(cache[cacheIdx].x, cache[cacheIdx + step].x);
        cache[cacheIdx].y = max(cache[cacheIdx].y, cache[cacheIdx + step].y);
        cache[cacheIdx].z = max(cache[cacheIdx].z, cache[cacheIdx + step].z);
      }
      GroupMemoryBarrierWithGroupSync();
      step = step >> 1; 
    }

    if(cacheIdx == 0){
        Lock();
        cvf_max[0].x = max(cache[0].x, cvf_max[0].x);
        cvf_max[0].y = max(cache[0].y, cvf_max[0].y);
        cvf_max[0].z = max(cache[0].z, cvf_max[0].z);
        Unlock();
    }
    //GroupMemoryBarrierWithGroupSync();
    //if(index == 0){
    //    float C = 1.0f;
    //    dt_write[0] = max(max(C * radious /  cvf_max[0].y, sqrt(radious/cvf_max[0].z)), (C * radious) / cvf_max[0].x);
    //}

}

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void MainComputeShader(uint3 Gid : SV_GroupID, //atm: -, 0...256, - in rows (Y)        --> current group index (dispatched by c++)
                       uint3 ThreadId : SV_DispatchThreadID, //atm: 0...256 in rows & columns (XY)   --> "global" thread id
                       uint3 GTid : SV_GroupThreadID, //atm: 0...256, -,- in columns (X)      --> current threadId in group / "local" threadId
                       uint GI : SV_GroupIndex)            //atm: 0...256 in columns (X)           --> "flattened" index of a thread within a group))
{
    
    int index = ThreadId.x;
    if(index >= numParticles) return;
    Particle particle = particles_read[index];

    
    float3 position = particles_read[index].position;
    float3 velocity = particles_read[index].velocity;
    float density = particlesDensity_read[index].density;
    
    float3 force = particlesForce_read[index].force;

    float3 acceleration = float3(0,0,0);
    acceleration +=  force / mass;

    velocity += acceleration * delta_time;
    position += velocity * delta_time;
    
    
    //enforce bounds
    if(position.x - epsilon < minBoundary.x){
        velocity.x *= damping;
        position.x  = minBoundary.x + epsilon;
    }
    else if(position.x + epsilon + 1 > maxBoundary.x){
        velocity.x *= damping;
        position.x  = maxBoundary.x - epsilon - 1;
    }


    if(position.y - epsilon < minBoundary.y){
        velocity.y *= damping;
        position.y  = minBoundary.y + epsilon;
    }else if(position.y + epsilon + 1 > maxBoundary.y){
        velocity.y *= damping;
        position.y  = maxBoundary.y - epsilon - 1;
    }
    if(position.z - epsilon < minBoundary.z){
        velocity.z *= damping;
        position.z  = minBoundary.z + epsilon;
    } else if(position.z + epsilon + 1 > maxBoundary.z){
        velocity.z *= damping;
        position.z  = maxBoundary.z - epsilon - 1;
    }
    
    




    particles_write[index].velocity = velocity;
    particles_write[index].position = position;
}